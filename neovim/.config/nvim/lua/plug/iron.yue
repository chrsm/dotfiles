import "macros" as { $ }

cfg =
  -- memory_management: "tab"
  buflisted: false
  repl_open_cmd: "topleft vertical 35 split"

repls =
  yue:
    yue:
      command: { "yue" }

export default {
  config: ->
    import "iron" as iron

    -- can't do this one by default, unfortunately
    cfg.visibility = require("iron.visibility").single

    iron.core.set_config cfg
    iron.core.add_repl_definitions repls

    vim.api.nvim_set_keymap "n", "<leader>rp", \
      ":lua require(\"plug.iron\").iron_open_repl(vim.bo.filetype)<CR>", \
      { noremap: true, silent: true }

    vim.api.nvim_set_keymap "n", "<leader>rq", \
      ":lua require(\"plug.iron\").iron_close(vim.bo.filetype)<CR>", \
      { noremap: true, silent: true }

    $nosilent "<leader>rl", "<Plug>(iron-send-line)<CR>"
    $nosilent "<leader>rr", "<Plug>(iron-repeat-cmd)<CR>"

  iron_open_repl: (ft) ->
    vim.cmd ":IronRepl #{ ft }"

  --[[
    <Plug>(iron-exit) sends just an \04, exiting the process.
    You can restart the repl by running `:lua require("iron").core.repl_restart()`.

    IMO, just exiting the process without closing the repl isn't desired.
    I'd rather just _close_ the repl and open a new one whenever I'm ready to.
  ]]
  iron_close: (ft) ->
    import "iron" as iron

    mem, _ = iron.ll.ensure_repl_exists ft
    unless mem
      return

    iron.core.focus_on ft
    vim.cmd ":bd!"
}

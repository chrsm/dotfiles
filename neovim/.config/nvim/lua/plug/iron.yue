import "macros" as { $ }

cfg =
  -- memory_management: "tab"
  buflisted: false
  repl_open_cmd: "topleft vertical 35 split"

repls =
  yue:
    yue:
      command: { "yue" }

export default {
  config: ->
    import "iron" as iron
    import "which-key" as wk

    -- can't do this one by default, unfortunately
    cfg.visibility = require("iron.visibility").single

    iron.core.set_config cfg
    iron.core.add_repl_definitions repls

    wk.register {
      name: "repl (iron)"
      p:
        * ":lua require('plug.iron').iron_open_repl(vim.bo.filetype)<CR>"
        * "Open repl for the current filetype"
      q:
        * ":lua require(\"plug.iron\").iron_close(vim.bo.filetype)<CR>"
        * "Close repl for current filetype"
      l:
        * "<Plug>(iron-send-line)<CR>"
        * "Send current line to repl"
      r:
        * "<Plug>(iron-repeat-cmd)<CR>"
        * "Repeat previous repl command"
    }, { mode: "n", prefix: "<leader>r", noremap: true, silent: true }

  iron_open_repl: (ft) ->
    vim.cmd ":IronRepl #{ ft }"

  --[[
    <Plug>(iron-exit) sends just an \04, exiting the process.
    You can restart the repl by running `:lua require("iron").core.repl_restart()`.

    IMO, just exiting the process without closing the repl isn't desired.
    I'd rather just _close_ the repl and open a new one whenever I'm ready to.
  ]]
  iron_close: (ft) ->
    import "iron" as iron

    mem, _ = iron.ll.ensure_repl_exists ft
    unless mem
      return

    iron.core.focus_on ft
    vim.cmd ":Bdelete!"
}
